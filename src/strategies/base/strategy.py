"""
Abstract base strategy class for trading strategies.

This module provides the foundation for implementing trading strategies with
standardized lifecycle management, configuration validation, and performance tracking.
"""

import asyncio
import logging
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, timedelta

import structlog
from pydantic import BaseModel, Field, validator

from ...core.config import ConfigurationManager
from ...utils.logging import get_logger


class StrategyStatus(Enum):
    """Strategy lifecycle status enumeration."""
    INITIALIZING = "initializing"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"


class SignalDirection(Enum):
    """Trading signal direction enumeration."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class StrategyMetrics:
    """Performance metrics for strategy tracking."""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: Decimal = Decimal('0')
    total_fees: Decimal = Decimal('0')
    max_drawdown: Decimal = Decimal('0')
    current_drawdown: Decimal = Decimal('0')
    sharpe_ratio: float = 0.0
    win_rate: float = 0.0
    avg_trade_duration: timedelta = timedelta()
    start_time: datetime = field(default_factory=datetime.now)
    last_trade_time: Optional[datetime] = None


@dataclass
class TradingSignal:
    """Trading signal generated by a strategy."""
    symbol: str
    direction: SignalDirection
    confidence: float  # 0.0 to 1.0
    quantity: Decimal
    price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)


class StrategyConfig(BaseModel):
    """Base configuration for all trading strategies."""

    name: str = Field(..., description="Strategy name")
    enabled: bool = Field(True, description="Whether strategy is enabled")
    symbols: List[str] = Field(..., description="Trading symbols")
    max_positions: int = Field(5, description="Maximum concurrent positions")
    risk_per_trade: Decimal = Field(Decimal('0.02'), description="Risk per trade as decimal")
    max_portfolio_risk: Decimal = Field(Decimal('0.1'), description="Max portfolio risk")

    # Timing configuration
    signal_frequency: int = Field(60, description="Signal generation frequency in seconds")
    order_timeout: int = Field(30, description="Order execution timeout in seconds")

    # Logging configuration
    log_level: str = Field("INFO", description="Logging level")
    log_signals: bool = Field(True, description="Whether to log trading signals")

    # Risk management
    stop_loss_enabled: bool = Field(True, description="Enable stop loss")
    take_profit_enabled: bool = Field(True, description="Enable take profit")
    max_slippage: Decimal = Field(Decimal('0.001'), description="Maximum slippage tolerance")

    @validator('risk_per_trade', 'max_portfolio_risk', 'max_slippage')
    def validate_decimals(cls, v):
        if v < 0:
            raise ValueError("Risk values must be non-negative")
        return v



class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Provides standardized lifecycle management, configuration validation,
    performance tracking, and integration points for the trading system.
    """

    def __init__(self, config: StrategyConfig, config_manager: ConfigurationManager):
        """Initialize the strategy.

        Args:
            config: Strategy configuration
            config_manager: Global configuration manager
        """
        self.config = config
        self.config_manager = config_manager
        self.status = StrategyStatus.INITIALIZING

        # Core components (to be injected)
        self._trading_engine = None
        self._risk_manager = None
        self._position_manager = None
        self._websocket_client = None

        # Strategy state
        self._running = False
        self._signal_task = None
        self._metrics = StrategyMetrics()

        # Logging
        self.logger = get_logger(f"strategy.{config.name}")

        # Performance tracking
        self._start_time = time.time()
        self._signal_count = 0
        self._last_signal_time = 0

    @property
    def name(self) -> str:
        """Strategy name."""
        return self.config.name

    @property
    def is_running(self) -> bool:
        """Whether the strategy is currently running."""
        return self._running and self.status == StrategyStatus.RUNNING

    @property
    def metrics(self) -> StrategyMetrics:
        """Strategy performance metrics."""
        return self._metrics

    @abstractmethod
    async def generate_signal(self, symbol: str, market_data: Dict[str, Any]) -> Optional[TradingSignal]:
        """
        Generate trading signal for a symbol.

        Args:
            symbol: Trading symbol
            market_data: Current market data

        Returns:
            Trading signal or None if no signal
        """
        pass

    @abstractmethod
    def calculate_position_size(self, signal: TradingSignal, portfolio_value: Decimal) -> Decimal:
        """
        Calculate position size based on signal and portfolio value.

        Args:
            signal: Trading signal
            portfolio_value: Current portfolio value

        Returns:
            Position size in base currency
        """
        pass

    @abstractmethod
    async def validate_signal(self, signal: TradingSignal) -> bool:
        """
        Validate if a signal should be executed.

        Args:
            signal: Trading signal to validate

        Returns:
            True if signal is valid for execution
        """
        pass

    def set_trading_engine(self, trading_engine):
        """Set the trading engine reference."""
        self._trading_engine = trading_engine

    def set_risk_manager(self, risk_manager):
        """Set the risk manager reference."""
        self._risk_manager = risk_manager

    def set_position_manager(self, position_manager):
        """Set the position manager reference."""
        self._position_manager = position_manager

    def set_websocket_client(self, websocket_client):
        """Set the websocket client reference."""
        self._websocket_client = websocket_client

    async def initialize(self) -> bool:
        """
        Initialize the strategy.

        Returns:
            True if initialization successful
        """
        try:
            self.logger.info("Initializing strategy")

            # Validate configuration
            await self._validate_configuration()

            # Strategy-specific initialization
            await self._initialize_strategy()

            self.status = StrategyStatus.RUNNING
            self.logger.info("Strategy initialized successfully")
            return True

        except Exception as e:
            self.logger.error("Failed to initialize strategy", error=str(e))
            self.status = StrategyStatus.ERROR
            return False

    async def start(self) -> bool:
        """
        Start the strategy execution.

        Returns:
            True if started successfully
        """
        try:
            if self.status != StrategyStatus.RUNNING:
                self.logger.error("Cannot start strategy in current state",
                                current_status=self.status.value)
                return False

            self.logger.info("Starting strategy")

            # Start signal generation loop
            self._running = True
            self._signal_task = asyncio.create_task(self._signal_generation_loop())

            self.logger.info("Strategy started successfully")
            return True

        except Exception as e:
            self.logger.error("Failed to start strategy", error=str(e))
            return False

    async def stop(self) -> bool:
        """
        Stop the strategy execution.

        Returns:
            True if stopped successfully
        """
        try:
            self.logger.info("Stopping strategy")
            self._running = False
            self.status = StrategyStatus.STOPPING

            # Cancel signal generation task
            if self._signal_task and not self._signal_task.done():
                self._signal_task.cancel()
                try:
                    await self._signal_task
                except asyncio.CancelledError:
                    pass

            # Strategy-specific cleanup
            await self._cleanup_strategy()

            self.status = StrategyStatus.STOPPED
            self.logger.info("Strategy stopped successfully")
            return True

        except Exception as e:
            self.logger.error("Failed to stop strategy", error=str(e))
            return False

    async def pause(self) -> bool:
        """
        Pause the strategy execution.

        Returns:
            True if paused successfully
        """
        if self.status == StrategyStatus.RUNNING:
            self.status = StrategyStatus.PAUSED
            self.logger.info("Strategy paused")
            return True
        return False

    async def resume(self) -> bool:
        """
        Resume the strategy execution.

        Returns:
            True if resumed successfully
        """
        if self.status == StrategyStatus.PAUSED:
            self.status = StrategyStatus.RUNNING
            self.logger.info("Strategy resumed")
            return True
        return False

    async def _signal_generation_loop(self):
        """Main signal generation loop."""
        self.logger.info("Starting signal generation loop")

        while self._running:
            try:
                # Generate signals for all symbols
                for symbol in self.config.symbols:
                    if not self._running:
                        break

                    try:
                        # Get market data (this would integrate with websocket client)
                        market_data = await self._get_market_data(symbol)
                        if market_data:
                            signal = await self.generate_signal(symbol, market_data)
                            if signal:
                                await self._process_signal(signal)

                    except Exception as e:
                        self.logger.error("Error generating signal for symbol",
                                        symbol=symbol, error=str(e))

                # Wait for next signal generation cycle
                await asyncio.sleep(self.config.signal_frequency)

            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error("Error in signal generation loop", error=str(e))
                await asyncio.sleep(1)  # Brief pause before retry

        self.logger.info("Signal generation loop stopped")

    async def _process_signal(self, signal: TradingSignal):
        """Process a generated trading signal."""
        try:
            # Log signal if enabled
            if self.config.log_signals:
                self.logger.info("Generated trading signal",
                               symbol=signal.symbol,
                               direction=signal.direction.value,
                               confidence=signal.confidence,
                               quantity=float(signal.quantity))

            # Validate signal
            if not await self.validate_signal(signal):
                self.logger.debug("Signal validation failed",
                                symbol=signal.symbol,
                                direction=signal.direction.value)
                return

            # Check risk limits
            if not await self._check_risk_limits(signal):
                self.logger.debug("Risk limit check failed",
                                symbol=signal.symbol,
                                direction=signal.direction.value)
                return

            # Execute signal through trading engine
            if self._trading_engine:
                await self._trading_engine.execute_signal(signal, self)

            # Update metrics
            self._metrics.last_trade_time = signal.timestamp
            self._signal_count += 1

        except Exception as e:
            self.logger.error("Error processing signal",
                            symbol=signal.symbol, error=str(e))

    async def _get_market_data(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Get current market data for a symbol."""
        # This would integrate with the websocket client to get real-time data
        if self._websocket_client:
            return await self._websocket_client.get_market_data(symbol)
        return None

    async def _check_risk_limits(self, signal: TradingSignal) -> bool:
        """Check if signal complies with risk limits."""
        try:
            # Check position limits
            if self._position_manager:
                current_positions = await self._position_manager.get_positions(self.name)
                if len(current_positions) >= self.config.max_positions:
                    return False

                # Check symbol-specific position
                symbol_positions = [p for p in current_positions if p.symbol == signal.symbol]
                if symbol_positions:
                    # Additional position size checks could go here
                    pass

            # Check portfolio risk
            if self._risk_manager:
                portfolio_risk = await self._risk_manager.get_portfolio_risk()
                if portfolio_risk > self.config.max_portfolio_risk:
                    return False

            return True

        except Exception as e:
            self.logger.error("Error checking risk limits", error=str(e))
            return False

    async def _validate_configuration(self) -> bool:
        """Validate strategy configuration."""
        try:
            # Basic configuration validation
            if not self.config.symbols:
                raise ValueError("No symbols configured")

            if self.config.risk_per_trade <= 0:
                raise ValueError("Invalid risk per trade")

            if self.config.max_positions <= 0:
                raise ValueError("Invalid max positions")

            # Strategy-specific validation
            await self._validate_strategy_config()

            return True

        except Exception as e:
            self.logger.error("Configuration validation failed", error=str(e))
            raise

    async def _initialize_strategy(self):
        """Strategy-specific initialization."""
        # Override in subclasses for custom initialization
        pass

    async def _validate_strategy_config(self):
        """Strategy-specific configuration validation."""
        # Override in subclasses for custom validation
        pass

    async def _cleanup_strategy(self):
        """Strategy-specific cleanup."""
        # Override in subclasses for custom cleanup
        pass

    def update_metrics(self, pnl: Decimal, fees: Decimal = Decimal('0')):
        """Update strategy performance metrics."""
        self._metrics.total_trades += 1
        self._metrics.total_pnl += pnl
        self._metrics.total_fees += fees

        if pnl > 0:
            self._metrics.winning_trades += 1
        else:
            self._metrics.losing_trades += 1

        # Update win rate
        total_trades = self._metrics.total_trades
        if total_trades > 0:
            self._metrics.win_rate = self._metrics.winning_trades / total_trades

    def get_status_info(self) -> Dict[str, Any]:
        """Get current strategy status information."""
        return {
            "name": self.config.name,
            "status": self.status.value,
            "is_running": self.is_running,
            "uptime_seconds": time.time() - self._start_time,
            "signals_generated": self._signal_count,
            "metrics": {
                "total_trades": self._metrics.total_trades,
                "win_rate": self._metrics.win_rate,
                "total_pnl": float(self._metrics.total_pnl),
                "max_drawdown": float(self._metrics.max_drawdown)
            }
        }